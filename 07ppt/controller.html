<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>📑 PPT 컨트롤러</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="../common/sidebar.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
</head>
<body>
  <div class="ppt-main main-content">
    <div class="reservation container-fluid px-4 mt-5">
      <div class="slide-controller-wrapper d-flex flex-column mt-5 mt-md-0 mb-3">
        <h2 class="mb-3 mb-md-3">📑 PPT 슬라이드 컨트롤러</h2>
        <button onclick="startPPT()" class="ppt-start-button"><span class="ppt-start-text">PPT 시작하기</span></button>
        <h3>✅ 선택된 슬라이드</h3>
        <div id="selected-slides">
          <div id="drop-indicator"></div>
        </div>
        <div class="slide-list" id="all-sets"></div>
      </div>
    </div>
  </div>

  <script>
    // ✅ 1. displayWindow는 전역 변수로 유지합니다.
    let displayWindow = null;
    const selectedSlides = [];
    const slideItemsMap = {};

    // ✅ 2. startPPT 함수를 수정합니다.
    function startPPT() {
      if (!selectedSlides.length) return alert("선택된 슬라이드가 없습니다.");

      // 이미 창이 열려있고 닫히지 않았다면,
      if (displayWindow && !displayWindow.closed) {
        displayWindow.focus(); // 창을 앞으로 가져오고
        // 이미 준비된 창이므로 데이터를 즉시 보냅니다.
        displayWindow.postMessage({ type: "slides", slides: selectedSlides }, "*");
      } else {
        // 새 창을 엽니다. 데이터는 아직 보내지 않습니다.
        displayWindow = window.open("display.html", "display_slides", "width=1000,height=700");
      }
      // 기존의 setTimeout 로직은 제거됩니다.
    }
    
    // ✅ 3. 'display_ready' 메시지를 수신하는 이벤트 리스너를 추가합니다.
    window.addEventListener('message', function(event) {
      // display.html로부터 "준비 완료" 신호가 왔는지 확인
      if (event.data && event.data.type === 'display_ready') {
        console.log("Display 페이지 준비 완료! 슬라이드 데이터를 전송합니다.");
        
        // displayWindow가 유효하고, 보낼 데이터가 있을 때만 전송
        if (displayWindow && !displayWindow.closed && selectedSlides.length > 0) {
          displayWindow.postMessage({ type: "slides", slides: selectedSlides }, "*");
        }
      }
    });


    // --- 아래의 다른 함수들은 수정할 필요가 없습니다 ---

    function makeSlideItem(src, labelText) {
      const li = document.createElement("li");
      li.className = "slide-item";

      const img = document.createElement("img");
      img.src = src;

      const label = document.createElement("div");
      label.className = "slide-label";
      label.textContent = labelText.replace(/\.[^/.]+$/, "");

      li.appendChild(img);
      li.appendChild(label);

      li.onclick = () => {
        const index = selectedSlides.indexOf(src);
        if (index !== -1) {
          selectedSlides.splice(index, 1);
          li.classList.remove("selected");
        } else {
          selectedSlides.push(src);
          li.classList.add("selected");
        }
        renderSelectedSlides();
      };

      slideItemsMap[src] = li;
      return li;
    }

    function addToSelected(src) {
      if (!selectedSlides.includes(src)) {
        selectedSlides.push(src);
        slideItemsMap[src]?.classList.add("selected");
        renderSelectedSlides();
      }
    }

    function renderSelectedSlides() {
      const container = document.getElementById("selected-slides");
      // ✅ 인디케이터를 제외한 기존 썸네일들만 먼저 삭제
      container.querySelectorAll('.slide-thumb').forEach(thumb => thumb.remove());

      const dropIndicator = document.getElementById('drop-indicator');

      selectedSlides.forEach((src, index) => {
        const div = document.createElement("div");
        div.className = "slide-thumb";
        div.draggable = true;

        // ... img, btn 생성 및 추가 로직 (이전과 동일) ...
        const img = document.createElement("img");
        img.src = src;
        const btn = document.createElement("button");
        btn.textContent = "x";
        btn.className = "remove-btn";
        btn.onclick = (e) => {
          e.stopPropagation();
          selectedSlides.splice(index, 1);
          if (slideItemsMap[src]) {
            slideItemsMap[src].classList.remove("selected");
          }
          renderSelectedSlides();
        };
        div.appendChild(img);
        div.appendChild(btn);
        // ... img, btn 로직 끝 ...
        
        // --- ✅ 드래그 앤 드롭 이벤트 핸들러 전체 수정 ---
        div.ondragstart = (e) => {
          e.dataTransfer.setData("index", index);
          setTimeout(() => div.classList.add("dragging"), 0);
        };

        div.ondragend = () => {
          div.classList.remove("dragging");
          // 드래그가 끝나면 인디케이터를 무조건 숨김
          dropIndicator.style.display = 'none';
        };

        div.ondragover = (e) => {
          e.preventDefault();
          // 인디케이터를 보여줌
          dropIndicator.style.display = 'block';

          // 마우스 위치 계산
          const rect = div.getBoundingClientRect();
          const midX = rect.left + rect.width / 2;

          // 인디케이터의 높이와 세로 위치 설정
          dropIndicator.style.height = `${div.offsetHeight}px`;
          dropIndicator.style.top = `${div.offsetTop}px`;
          
          // 마우스가 왼쪽 절반에 있으면 요소의 왼쪽에, 아니면 오른쪽에 라인 표시
          if (e.clientX < midX) {
            dropIndicator.style.left = `${div.offsetLeft - 2}px`; // -2는 라인 두께의 절반
          } else {
            dropIndicator.style.left = `${div.offsetLeft + div.offsetWidth - 2}px`;
          }
        };

        div.ondrop = (e) => {
          e.preventDefault();
          // 드롭 후 인디케이터 숨김
          dropIndicator.style.display = 'none';

          const fromIndex = parseInt(e.dataTransfer.getData("index"), 10);
          let toIndex = index;

          // 마우스 위치를 다시 계산하여 최종 드롭 위치 결정
          const rect = div.getBoundingClientRect();
          const midX = rect.left + rect.width / 2;
          
          // 마우스가 오른쪽 절반에 드롭되었다면, 삽입 위치는 해당 요소의 '다음'
          if (e.clientX > midX) {
            toIndex++;
          }
          
          if (fromIndex === toIndex) return;

          const movedItem = selectedSlides.splice(fromIndex, 1)[0];
          if (fromIndex < toIndex) {
            toIndex--;
          }
          selectedSlides.splice(toIndex, 0, movedItem);
          renderSelectedSlides();
        };

        // container에 자식으로 추가할 때, 인디케이터보다 앞에 추가
        container.appendChild(div);
      });
    }

    fetch("slides.json")
          .then(res => res.json())
          .then(data => {
            const container = document.getElementById("all-sets");

            Object.entries(data).forEach(([group, content]) => {
              
              // ✅ 1. h3 제목을 먼저 생성해서 메인 컨테이너('all-sets')에 바로 추가합니다.
              const groupTitle = document.createElement("h3");
              groupTitle.className = "slide-group-title";
              groupTitle.textContent = group;
              container.appendChild(groupTitle);

              // ✅ 2. h3을 제외한 '콘텐츠만'을 담을 Wrapper div를 생성합니다.
              const groupWrapper = document.createElement("div");
              const safeClassName = group.replace(/\s+/g, '-');
              groupWrapper.className = "slide-group-container";
              groupWrapper.classList.add(`group-${safeClassName}`);

              // --- 이제부터 h4, ul 등의 콘텐츠는 모두 이 groupWrapper에 추가됩니다. ---
              
              if (Array.isArray(content)) {
                const ul = document.createElement("ul");
                content.forEach(file => {
                  const fullPath = `ppt-slides/${group}/${file}`;
                  ul.appendChild(makeSlideItem(fullPath, file));
                });
                groupWrapper.appendChild(ul);
              } 
              else if (typeof content === 'object' && content !== null) {
                Object.entries(content).forEach(([subName, files]) => {
                  if(Array.isArray(files)) {
                    const subTitle = document.createElement("h4");
                    subTitle.className = "slide-subgroup-title";
                    subTitle.textContent = subName;
                    groupWrapper.appendChild(subTitle);
                    
                    const ul = document.createElement("ul");
                    files.forEach(file => {
                      const fullPath = `ppt-slides/${group}/${subName}/${file}`;
                      ul.appendChild(makeSlideItem(fullPath, file));
                    });
                    groupWrapper.appendChild(ul);
                  }
                  else {
                    const ul = document.createElement("ul");
                    const fullPath = `ppt-slides/${group}/${subName}`;
                    ul.appendChild(makeSlideItem(fullPath, subName));
                    groupWrapper.appendChild(ul);
                  }
                });
              }
              
              // ✅ 3. 콘텐츠가 모두 채워진 Wrapper div를 메인 컨테이너에 추가합니다.
              container.appendChild(groupWrapper);
            });
          });
    
  </script>
  <script src="/common/sidebar.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>
</body>
</html>
