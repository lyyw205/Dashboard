<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>자리 배치 결과</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="content-wrapper">
      <h2 id="result-title" style="text-align:center; width: 210px;">자리를 섞는 중...</h2>
      <div id="result-wrapper" class="result-wrapper"></div>
    </div>
    <script>
        let animationIntervalHandler = null;
        function runAnimation() {
            const tablesData = JSON.parse(localStorage.getItem('seatingData'));
            const wrapper = document.getElementById('result-wrapper');
            const title = document.getElementById('result-title');
            wrapper.innerHTML = '';
            title.textContent = '자리를 섞는 중...';
            if (animationIntervalHandler) clearInterval(animationIntervalHandler);
            if (!tablesData) { wrapper.innerHTML = "<h2>데이터 없음</h2>"; return; }

            function shuffleArray(array) {
                for(let i = array.length - 1; i > 0; i--){ const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; }
                return array;
            }

            // 1. 전체 인원 번호 풀 생성
            let totalMen = 0, totalWomen = 0;
            tablesData.forEach(t => { totalMen += t.men; totalWomen += t.women; });
            const menNumbers = shuffleArray(Array.from({ length: totalMen }, (_, i) => (i + 1) * 2));
            const womenNumbers = shuffleArray(Array.from({ length: totalWomen }, (_, i) => i * 2 + 1));

            // 2. "사람 번호 -> 이전 테이블 이름" 맵 생성 (핵심)
            const personToOldTableMap = new Map();
            const tempMen = [...menNumbers];
            const tempWomen = [...womenNumbers];
            tablesData.forEach(table => {
                for (let i = 0; i < table.men; i++) personToOldTableMap.set(tempMen.shift(), table.name);
                for (let i = 0; i < table.women; i++) personToOldTableMap.set(tempWomen.shift(), table.name);
            });

            // 3. 새 테이블 구조 초기화 및 고정석 우선 배정
            const finalAssignments = new Array(totalMen + totalWomen).fill(null);
            const newTableLayout = []; // { name, capacity, people: [] }
            let remainingMen = [...menNumbers];
            let remainingWomen = [...womenNumbers];
            let unassignedSlots = []; // { newTableIndex, slotIndex, globalIndex }
            let seatCounter = 0;

            tablesData.forEach((table, tableIndex) => {
                newTableLayout.push({ name: table.name, capacity: table.seats.length, people: [] });
                table.seats.forEach((seat, seatIndex) => {
                    const globalIndex = seatCounter + seatIndex;
                    if (seat.fixed === 'male') {
                        const person = remainingMen.shift();
                        finalAssignments[globalIndex] = person;
                        newTableLayout[tableIndex].people.push(person);
                    } else if (seat.fixed === 'female') {
                        const person = remainingWomen.shift();
                        finalAssignments[globalIndex] = person;
                        newTableLayout[tableIndex].people.push(person);
                    } else {
                        unassignedSlots.push({ newTableIndex, slotIndex, globalIndex });
                    }
                });
                seatCounter += table.seats.length;
            });

            // 4. 나머지 사람들을 나머지 자리에 배정 (규칙 적용)
            const remainingPeople = shuffleArray([...remainingMen, ...remainingWomen]);
            
            remainingPeople.forEach(person => {
                const personOldTable = personToOldTableMap.get(person);
                let placed = false;
                
                // 섞인 빈자리 목록을 순회하며 가능한 곳을 찾음
                for (let i = 0; i < unassignedSlots.length; i++) {
                    const slot = unassignedSlots[i];
                    const newTable = newTableLayout[slot.newTableIndex];
                    
                    // 현재 새 테이블에 있는 사람들의 이전 테이블 목록을 가져옴
                    const oldTablesInNewTable = newTable.people.map(p => personToOldTableMap.get(p));

                    // 만약 이 사람의 이전 테이블이 새 테이블에 없다면, 배정 가능!
                    if (!oldTablesInNewTable.includes(personOldTable)) {
                        finalAssignments[slot.globalIndex] = person;
                        newTable.people.push(person);
                        unassignedSlots.splice(i, 1); // 배정된 자리는 목록에서 제거
                        placed = true;
                        break;
                    }
                }
                
                // 만약 모든 테이블을 확인해도 규칙상 갈 곳이 없다면, 그냥 첫 번째 빈자리에 배정 (예외 처리)
                if (!placed && unassignedSlots.length > 0) {
                    const slot = unassignedSlots.shift();
                    finalAssignments[slot.globalIndex] = person;
                    newTableLayout[slot.newTableIndex].people.push(person);
                }
            });
            
            // --- [수정됨] 화면 그리기 (좌표 기반) ---
            tablesData.forEach(table => {
                let seatsHtml = '';
                table.seats.forEach(seat => {
                    // 저장된 x, y 좌표를 transform 속성에 적용
                    seatsHtml += `<div class="seat" style="transform: translate(${seat.x}px, ${seat.y}px);">?</div>`;
                });
                wrapper.innerHTML += `<div class="table-canvas"><div class="table-center-drag">${table.name}</div>${seatsHtml}</div></div>`;
            });
            
            const allSeatElements = document.querySelectorAll('.seat');
            
            function startRoulette() {
                animationIntervalHandler = setInterval(() => {
                    allSeatElements.forEach(seat => {
                        const randomNumber = Math.floor(Math.random() * (totalMen + totalWomen)) + 1;
                        seat.textContent = randomNumber; seat.className = 'seat';
                    });
                }, 80);
            }
            function stopRoulette() {
                clearInterval(animationIntervalHandler);
                title.textContent = "학창시절 느낌 그대로";
                allSeatElements.forEach((seat, index) => {
                    const person = finalAssignments[index];
                    if (person !== undefined) {
                        seat.textContent = person;
                        seat.className = person % 2 === 0 ? 'seat male' : 'seat female';
                    } else { seat.textContent = '공석'; seat.className = 'seat'; }
                });
            }
            startRoulette();
            setTimeout(stopRoulette, 3000);
        }
        window.onload = runAnimation;
        // --- [추가됨] 독립적인 확대/축소 기능 ---
        let zoomLevel = 1.0; // 현재 확대 비율 (1.0 = 100%)
        const zoomStep = 0.1;  // 한 번에 10%씩 조절
        const maxZoom = 2.0;   // 최대 200%
        const minZoom = 0.5;   // 최소 50%

        // body 전체에 마우스 휠 이벤트 리스너 추가
        document.body.addEventListener('wheel', function(event) {
            // Ctrl 키가 눌렸을 때만 작동
            if (event.ctrlKey) {
                // 브라우저의 기본 확대/축소 동작을 막음
                event.preventDefault();

                // 휠을 위로 올리면(event.deltaY < 0) 확대, 아래로 내리면 축소
                if (event.deltaY < 0) {
                    zoomLevel += zoomStep;
                } else {
                    zoomLevel -= zoomStep;
                }

                // 최대/최소 배율을 넘지 않도록 제한
                zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel));

                // body의 transform: scale 속성을 변경하여 내용물 크기 조절
                document.body.style.transform = `scale(${zoomLevel})`;
            }
        }, { passive: false }); // preventDefault를 사용하기 위한 옵션
    </script>
</body>
</html>