<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>카드 결제 내역</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="../common/sidebar.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
</head>
<body>
  <div class="cardlogs-main main-content">
    <div class="reservation container-fluid px-4 mt-5">
            <!-- NEW! 필터 및 차트 영역 -->
      <div class="filter-wrapper mt-5 mb-4">
        <h2 class="mb-3">📊 필터링 데이터 추출</h2>
        <div class="filter-section mb-3">
          <div class="row g-3 align-items-end">
            <!-- 날짜 범위 선택 -->
            <div class="col-md-2">
              <label for="startDate" class="form-label"><b>시작일</b></label>
              <input type="date" id="startDate" class="form-control">
            </div>
            <div class="col-md-2">
              <label for="endDate" class="form-label"><b>종료일</b></label>
              <input type="date" id="endDate" class="form-control">
            </div>
            <!-- 종류 선택 버튼 (입금/출금) -->
            <div class="col-md-2 w-auto">
              <label class="form-label d-block"><b>입/출금</b></label>
              <div id="type-buttons-container" class="d-flex flex-wrap gap-2">
                  <button class="btn type-btn active" data-type="출금">출금</button>
                  <button class="btn type-btn" data-type="입금">입금</button>
              </div>
            </div>
            <!-- 메모 인풋 -->
            <div class="memo-filter-wrapper col-md-4">
              <label for="memo-search-input" class="form-label"><strong>📝 메모 내용을 포함하는 항목 검색</strong></label>
              <input type="text" id="memo-search-input" class="form-control" placeholder="검색할 메모 내용을 입력하세요...">
            </div>
          </div>
          <!-- 카테고리 선택 버튼 -->
          <div class="mt-3">
            <label class="form-label d-block"><b>카테고리 (중복 선택 가능)</b></label>
            <div id="category-buttons-container" class="d-flex flex-wrap gap-2">
              <!-- JS로 버튼 동적 생성 -->
            </div>
          </div>
                    <!-- 조회 버튼 -->
          <div class="col-md-3 mt-3">
            <button id="filter-btn" class="btn btn-search w-100">조회하기</button>
          </div>
        </div>
        <div id="summary-container" class="summary-container mt-4 p-3 border rounded bg-light" style="display: none;">
          <div class="row">
            <div class="col-2">
              <p class="summary-label">총 입금액</p>
              <p id="total-deposit" class="summary-value deposit-color">0 원</p>
            </div>
            <div class="col-2">
              <p class="summary-label">총 출금액</p>
              <p id="total-withdrawal" class="summary-value withdrawal-color">0 원</p>
            </div>
          </div>
        </div>
        
        <!-- 차트가 그려질 영역 -->
        <div id="chart-container">
          <canvas id="category-chart"></canvas>
        </div>
      </div>
      <div class="table-wrapper d-flex flex-column mt-5 mb-3">
        <h2 class="mb-3 mb-md-3">💳카드 결제 내역</h2>
        <div class="p-3 mb-3 border rounded bg-light">
          <div class="row g-3">
            <!-- 날짜 필터 -->
            <div class="col-md-2">
              <label for="table-start-date" class="form-label"><strong> 시작일</strong></label>
              <input type="date" id="table-start-date" class="form-control">
            </div>
            <div class="col-md-2">
              <label for="table-end-date" class="form-label"><strong> 종료일</strong></label>
              <input type="date" id="table-end-date" class="form-control">
            </div>
            <!-- 카테고리 필터 -->
            <div class="mb-3 col-md-2">
              <label for="table-category-filter" class="form-label"><strong> 카테고리</strong></label>
              <select id="table-category-filter" class="form-select">
                <option value="all">-- 전체 보기 --</option>
                <!-- 카테고리는 JavaScript로 채워집니다 -->
              </select>
            </div>
                <!-- 종류 필터 -->
            <div class="col-md-2">
              <label for="table-type-filter" class="form-label"><strong> 종류</strong></label>
              <select id="table-type-filter" class="form-select">
                <option value="all">-- 전체 --</option>
                <option value="출금">출금</option>
                <option value="입금">입금</option>
              </select>
            </div>
            <div class="col-md-2">
              <label for="table-store-search" class="form-label"><strong> 결제처 검색</strong></label>
              <input type="text" id="table-store-search" class="form-control" placeholder="결제처명 입력">
            </div>
            <div class="col-md-2">
              <label for="table-memo-search" class="form-label"><strong> 메모 검색</strong></label>
              <input type="text" id="table-memo-search" class="form-control" placeholder="메모 내용 입력">
            </div>
          </div>
        </div>
        
        <div class="table-responsive">
          <table id="log-table" class="log-table table table-borderless table-hover align-middle text-center table-striped-custom">
            <thead class="table-dark">
              <tr>
                <th>시간</th>
                <th>카테고리</th>
                <th>금액</th>
                <th>카드</th>
                <th>종류</th>
                <th>잔액</th>
                <th>결제처</th>
                <th>메모</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <nav aria-label="Page navigation" class="d-flex justify-content-center mt-4">
          <ul class="pagination" id="pagination-controls">
            <!-- 페이지 번호는 JavaScript가 동적으로 생성합니다. -->
          </ul>
        </nav>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
  <script>
    // ✅ 변수명 이름 충돌 방지
    const supa = window.supabase.createClient(
      'https://wqxmvqqkbxiykiotbusd.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndxeG12cXFrYnhpeWtpb3RidXNkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0NDcyOTYsImV4cCI6MjA2NDAyMzI5Nn0.RmB92YtjLPMx4tkQibuRVT_T4DL3_O8Pny3ZA9DU0tk'
    );
    Chart.register(ChartDataLabels);

    const categories = ['광고', '장소 대관', '주류', '비품/안주', '업무추진비', '공과금', '파티비', '현장판매', '대관', '기타'];

        // ★★★ [신규] 페이지네이션을 위한 전역 변수 추가 ★★★
    const ITEMS_PER_PAGE = 70; // 한 페이지에 50개씩 표시 (원하는 숫자로 조절)
    let currentPage = 1;

    function formatNumber(num) {
        return typeof num === 'number' ? num.toLocaleString('ko-KR') : '';
    }

    function formatDateForInput(input) {
      // 1. 입력값이 없는 경우, 에러 방지를 위해 빈 문자열 반환
      if (!input) return '';

      // 2. 입력값이 Date 객체인 경우 (setDefaultDateRange에서 호출될 때)
      if (input instanceof Date) {
        // toISOString()을 사용하면 'YYYY-MM-DDTHH:...' 형식이 되므로,
        // 앞 10자리를 잘라 'YYYY-MM-DD'를 반환합니다. 이 방법이 가장 안전합니다.
        return input.toISOString().slice(0, 10);
      }

      // 3. 입력값이 문자열인 경우 (applyTableFilters에서 호출될 때)
      if (typeof input === 'string' && input.length >= 10) {
        // 문자열의 앞 10자리를 잘라 'YYYY-MM-DD'를 반환합니다.
        return input.substring(0, 10);
      }
      
      // 4. 그 외의 모든 예외적인 경우
      return '';
    }

    function formatDateCompact(dateString) {
      if (!dateString || dateString.length < 16) return '';

      // "2025-07-19T18:54:00+00:00" 형태의 문자열을 가정
      const month = dateString.substring(5, 7);
      const day = dateString.substring(8, 10);
      const hour = dateString.substring(11, 13);
      const minute = dateString.substring(14, 16);

      return `${month}/${day} ${hour}:${minute}`;
    }

    //=======================================================
    // 차트 및 필터링 관련 로직
    //=======================================================
    const typeButtonsContainer = document.getElementById('type-buttons-container');
    const categoryButtonsContainer = document.getElementById('category-buttons-container');
    const filterBtn = document.getElementById('filter-btn');
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    let categoryChart = null; 
    const memoSearchInput = document.getElementById('memo-search-input');
    const tableStartDate = document.getElementById('table-start-date');
    const tableEndDate = document.getElementById('table-end-date');
    const tableTypeFilter = document.getElementById('table-type-filter');
    const tableCategoryFilter = document.getElementById('table-category-filter');
    const tableMemoSearch = document.getElementById('table-memo-search');
    const tableStoreSearch = document.getElementById('table-store-search');

    // [신규] 기본 날짜 범위(오늘 ~ 2주 전)를 설정하는 함수
    function setDefaultDateRange() {
      const today = new Date();
      const twoWeeksAgo = new Date();
      twoWeeksAgo.setDate(today.getDate() - 14);

      endDateInput.value = formatDateForInput(today);
      startDateInput.value = formatDateForInput(twoWeeksAgo);
    }

    function createCategoryButtons() {
      categories.forEach(cat => {
        const button = document.createElement('button');
        button.className = 'btn btn-category category-btn'; // Use secondary for non-active
        button.textContent = cat;
        button.dataset.category = cat;
        categoryButtonsContainer.appendChild(button);
      });
    }
    
    typeButtonsContainer.addEventListener('click', (e) => {
      if (e.target.classList.contains('type-btn')) {
        // 클릭된 버튼의 active 클래스를 단순히 토글(toggle)만 합니다.
        e.target.classList.toggle('active');
      }
    });

    categoryButtonsContainer.addEventListener('click', (e) => {
      // 버튼이 'category-btn' 클래스를 가지고 있는지 확인
      if (e.target.classList.contains('category-btn')) {
        // 'active' 클래스를 붙였다 떼는(토글) 역할만 수행
        e.target.classList.toggle('active');
      }
    });

    filterBtn.addEventListener('click', async () => {
        const startDateValue = startDateInput.value; // 예: "2025-07-19"
        const endDateValue = endDateInput.value;   // 예: "2025-07-20"

        if (!startDateValue || !endDateValue) {
            alert('시작일과 종료일을 모두 선택해주세요.');
            return;
        }

        // [✅ 이렇게 수정됩니다]
        // new Date()와 .toISOString()을 모두 제거합니다.
        // 사용자가 선택한 날짜 문자열에 시간 정보만 붙여서 DB로 보낼 문자열을 만듭니다.
        // 이렇게 하면 시간대 변환이 전혀 일어나지 않습니다.
        const startDateForDB = `${startDateValue} 00:00:00`;
        const endDateForDB = `${endDateValue} 23:59:59`;

        const selectedChartTypes = Array.from(typeButtonsContainer.querySelectorAll('.type-btn.active')).map(btn => btn.dataset.type);
        const chartTypesToQuery = [...selectedChartTypes];
        if (selectedChartTypes.includes('출금') && !chartTypesToQuery.includes('출금취소')) {
            chartTypesToQuery.push('출금취소');
        }

        if (chartTypesToQuery.length === 0) {
            alert('하나 이상의 종류(입금/출금)를 선택해주세요.');
            return;
        }

        const selectedChartCategories = Array.from(categoryButtonsContainer.querySelectorAll('.category-btn.active')).map(btn => btn.dataset.category);
        if (selectedChartCategories.length === 0) {
            alert('하나 이상의 카테고리를 선택해주세요.');
            return;
        }

        const chartMemoText = memoSearchInput.value.trim();
        
        // 생성된 'YYYY-MM-DD HH:mm:ss' 형식의 문자열을 그대로 전달합니다.
        await fetchDataAndDisplayResults(startDateForDB, endDateForDB, selectedChartCategories, chartTypesToQuery, chartMemoText);
    });

    async function loadTableData(page = 1) {
        currentPage = page;
        const tbody = document.querySelector('#log-table tbody');
        tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted py-5"><span class="spinner-border spinner-border-sm"></span> 로딩 중...</td></tr>`;

        // 1. 하단 테이블 필터들의 현재 값을 모두 읽어옵니다.
        const startDate = document.getElementById('table-start-date').value;
        const endDate = document.getElementById('table-end-date').value;
        const selectedType = document.getElementById('table-type-filter').value;
        const selectedCategory = document.getElementById('table-category-filter').value;
        const memoSearch = document.getElementById('table-memo-search').value.trim();
        const storeSearch = document.getElementById('table-store-search').value.trim();

        const from = (page - 1) * ITEMS_PER_PAGE;
        const to = page * ITEMS_PER_PAGE - 1;

        // 2. 읽어온 필터 값을 바탕으로 Supabase 쿼리를 동적으로 구성합니다.
        let query = supa
            .from('card_logs')
            .select('*', { count: 'exact' }) // 전체 개수도 함께 요청
            .order('timeline', { ascending: false }); // 최신순으로 변경 (or true)

        if (startDate) query = query.gte('timeline', `${startDate} 00:00:00`);
        if (endDate) query = query.lte('timeline', `${endDate} 23:59:59`);
        if (selectedCategory !== 'all') query = query.eq('category', selectedCategory);
        if (memoSearch) query = query.ilike('memo', `%${memoSearch}%`);
        if (storeSearch) query = query.ilike('store', `%${storeSearch}%`);
        
        // '출금' 선택 시 '출금취소'도 포함
        if (selectedType === '출금') {
            query = query.in('type', ['출금', '출금취소']);
        } else if (selectedType !== 'all') {
            query = query.eq('type', selectedType);
        }

        // 3. 페이지네이션을 위한 .range()를 마지막에 추가합니다.
        query = query.range(from, to);
        
        const { data, error, count } = await query;
        tbody.innerHTML = ''; // 테이블 내용 비우기

        if (error) {
            console.error('테이블 데이터 로드 오류:', error);
            tbody.innerHTML = `<tr><td colspan="8">데이터를 불러오지 못했습니다.</td></tr>`;
            return;
        }

        if (!data.length) {
            tbody.innerHTML = `<tr><td colspan="8">해당 조건의 결과가 없습니다.</td></tr>`;
            renderPagination(0); // 페이지네이션 숨기기
            return;
        }

        // 4. 받아온 데이터로 테이블 행을 만듭니다.
        data.forEach(row => appendRow(row));

        // 5. 전체 개수를 바탕으로 페이지네이션 UI를 렌더링합니다.
        renderPagination(count);
    }

        // ★★★ [신규] 페이지네이션 UI 렌더링 함수 ★★★
    function renderPagination(totalItems) {
        const paginationContainer = document.getElementById('pagination-controls');
        paginationContainer.innerHTML = '';
        const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);

        if (totalPages <= 1) return;
        
        // 이전 버튼
        paginationContainer.innerHTML += `<li class="page-item ${currentPage === 1 ? 'disabled' : ''}"><a class="page-link" href="#" onclick="event.preventDefault(); loadTableData(${currentPage - 1});">이전</a></li>`;
        
        // 페이지 번호 버튼
        for (let i = 1; i <= totalPages; i++) {
            paginationContainer.innerHTML += `<li class="page-item ${i === currentPage ? 'active' : ''}"><a class="page-link" href="#" onclick="event.preventDefault(); loadTableData(${i});">${i}</a></li>`;
        }

        // 다음 버튼
        paginationContainer.innerHTML += `<li class="page-item ${currentPage === totalPages ? 'disabled' : ''}"><a class="page-link" href="#" onclick="event.preventDefault(); loadTableData(${currentPage + 1});">다음</a></li>`;
    }
    
    async function fetchDataAndDisplayResults(startDate, endDate, categories, typesToQuery, memoText) {
        // 1. DB에서 데이터 조회
        let query = supa.from('card_logs').select('category, amount, type')
            .in('type', typesToQuery)
            .gte('timeline', startDate)
            .lte('timeline', endDate)
            .in('category', categories);
        if (memoText) query = query.ilike('memo', `%${memoText}%`);

        const { data: rawData, error } = await query;
        if (error) { /* ... */ return; }

        // 2. 총액 계산 및 화면 표시
        let totalDeposit = 0;
        let totalWithdrawal = 0;
        rawData.forEach(item => {
            if (item.type === '입금') totalDeposit += item.amount;
            else if (item.type === '출금') totalWithdrawal += item.amount;
            else if (item.type === '출금취소') totalWithdrawal -= item.amount;
        });
        document.getElementById('total-deposit').textContent = `${formatNumber(totalDeposit)} 원`;
        document.getElementById('total-withdrawal').textContent = `${formatNumber(totalWithdrawal)} 원`;
        document.getElementById('summary-container').style.display = 'block';

        // 3. 카테고리별 데이터 집계
        const depositCategoryTotals = {};
        const withdrawalCategoryTotals = {};
        categories.forEach(cat => {
            depositCategoryTotals[cat] = 0;
            withdrawalCategoryTotals[cat] = 0;
        });
        rawData.forEach(item => {
            if (item.type === '입금') {
                if (depositCategoryTotals.hasOwnProperty(item.category)) depositCategoryTotals[item.category] += item.amount;
            } else if (item.type === '출금' || item.type === '출금취소') {
                if (withdrawalCategoryTotals.hasOwnProperty(item.category)) {
                    if(item.type === '출금') withdrawalCategoryTotals[item.category] += item.amount;
                    else withdrawalCategoryTotals[item.category] -= item.amount;
                }
            }
        });

        // 4. ★★★ 실제 차트에 표시할 데이터만 필터링 ★★★
        const dynamicLabels = [];
        const dynamicDepositValues = [];
        const dynamicWithdrawalValues = [];
        categories.forEach(label => {
            const depositValue = depositCategoryTotals[label] || 0;
            const withdrawalValue = withdrawalCategoryTotals[label] || 0;
            if (depositValue > 0 || withdrawalValue > 0) {
                dynamicLabels.push(label);
                dynamicDepositValues.push(depositValue);
                dynamicWithdrawalValues.push(withdrawalValue);
            }
        });

        // 5. 모든 가공이 끝난 최종 데이터를 다음 함수에 전달
        renderDualCategoryChart(dynamicLabels, dynamicDepositValues, dynamicWithdrawalValues, totalDeposit, totalWithdrawal);
    }
        
    function renderDualCategoryChart(chartLabels, depositValues, withdrawalValues, totalDeposit, totalWithdrawal) {
        const chartContainer = document.getElementById('chart-container');
        const ctx = document.getElementById('category-chart').getContext('2d');
        
        if (categoryChart) {
            categoryChart.destroy();
        }

        // ★★★ (핵심) 가운데 정렬을 위한 패딩 로직 ★★★
        // 이 함수는 이제 데이터 가공 없이 전달받은 값을 그대로 사용합니다.
        const MIN_DISPLAY_CATEGORIES = 7;
        const numActiveCategories = chartLabels.length;

        let finalLabels = chartLabels;
        let finalDepositValues = depositValues;
        let finalWithdrawalValues = withdrawalValues;

        if (numActiveCategories > 0 && numActiveCategories < MIN_DISPLAY_CATEGORIES) {
            const paddingCount = Math.floor((MIN_DISPLAY_CATEGORIES - numActiveCategories) / 2);
            const labelPadding = Array(paddingCount).fill('');
            const dataPadding = Array(paddingCount).fill(null);
            finalLabels = [...labelPadding, ...chartLabels, ...labelPadding];
            finalDepositValues = [...dataPadding, ...depositValues, ...dataPadding];
            finalWithdrawalValues = [...dataPadding, ...withdrawalValues, ...dataPadding];
        }
        // ★★★ 패딩 로직 끝 ★★★


        // --- 3. 차트 렌더링 ---
        const chartTitle = '선택된 기간 및 카테고리별 입/출금 현황';

        categoryChart = new Chart(ctx, {
            type: 'bar',
            data: {
                // ★★★ 패딩이 적용된 최종 데이터를 사용합니다 ★★★
                labels: finalLabels,
                datasets: [
                    {
                        label: '총 입금액 (원)',
                        data: finalDepositValues,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)'
                        // maxBarThickness 등은 이제 불필요하므로 제거해도 좋습니다.
                    },
                    {
                        label: '총 출금액 (원)',
                        data: finalWithdrawalValues,
                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                        borderColor: 'rgba(255, 99, 132, 1)'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                // bar 관련 너비 옵션
                categoryPercentage: 0.8, // 카테고리 열 내에서 막대 그룹이 차지하는 너비 비율
                barPercentage: 0.7,      // 막대 그룹 내에서 각 막대가 차지하는 너비 비율
                plugins: {
                    // 데이터 라벨 플러그인 설정은 그대로 유지
                    datalabels: {
                        display: context => context.dataset.data[context.dataIndex] > 0,
                        formatter: (value, context) => {
                            // 1. 총액 계산 (기존과 동일)
                            let total = context.datasetIndex === 0 ? totalDeposit : totalWithdrawal;
                            
                            // 2. 백분율 계산 및 소수점 제거 (Math.round 사용)
                            const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
                            
                            // 3. 금액 포맷팅 및 '원' 추가
                            const formattedValue = new Intl.NumberFormat('ko-KR').format(value) + '원';
                            
                            // 4. 백분율이 위로, 금액이 아래로 오도록 순서 변경 및 최종 문자열 반환
                            return `${percentage}%\n${formattedValue}`;
                        },
                        anchor: 'start',
                        align: 'center',
                        offset: 0,
                        font: {
                            family: "'Pretendard Variable', sans-serif", // 원하는 폰트 패밀리 지정
                            weight: '500',
                            size: 12,
                            lineHeight: 1.5 // 줄 간격 조절
                        },
                        color: '#333',
                        textAlign: 'center' // 두 줄 텍스트 가운데 정렬
                    },
                    title: { display: true, text: chartTitle, font: { size: 16 } },
                    legend: { position: 'top' },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          let label = context.dataset.label || '';
                          if (label) { label += ': '; }
                          if (context.parsed.y !== null) {
                              label += new Intl.NumberFormat('ko-KR').format(context.parsed.y) + ' 원';
                          }
                          return label;
                        }
                      }
                    }
                },
                scales: {
                    x: {
                        stacked: false,
                        ticks: {
                            padding: 20, // x축과 라벨 사이의 간격을 10px로 설정
                            font: {
                                size: 13,       // 폰트 크기를 13px로 설정 (원하는 크기로 조절)
                                weight: 'bold', // 폰트를 굵게(bold) 설정
                                family: "'Pretendard Variable', sans-serif" // 폰트 종류 지정
                            }
                        }
                    },
                    y: {
                        stacked: false,
                        beginAtZero: true,
                        ticks: {
                            callback: value => new Intl.NumberFormat('ko-KR').format(value)
                        },
                        grace: '20%'
                    }
                }
            }
        });
        chartContainer.style.display = 'block';
    }

    // [수정] 모든 필터 이벤트가 통합 함수를 호출하도록 연결
    document.getElementById('table-start-date').addEventListener('change', () => loadTableData(1));
    document.getElementById('table-end-date').addEventListener('change', () => loadTableData(1));
    document.getElementById('table-type-filter').addEventListener('change', () => loadTableData(1));
    document.getElementById('table-category-filter').addEventListener('change', () => loadTableData(1));
    document.getElementById('table-memo-search').addEventListener('input', () => loadTableData(1));
    document.getElementById('table-store-search').addEventListener('input', () => loadTableData(1));


    function appendRow(row) {
        const tbody = document.querySelector('#log-table tbody');
        const tr = document.createElement('tr');
        // KST/UTC 혼동을 막기 위해 기준이 되는 UTC 시간을 data 속성에 저장
        tr.dataset.timeline = row.timeline;

        const categoryOptions = categories.map(cat =>
            `<option value="${cat}" ${row.category === cat ? 'selected' : ''}>${cat}</option>`
        ).join('');
        const typeOptions = ['출금', '입금', '출금취소', '기타'].map(type =>
            `<option value="${type}" ${row.type === type ? 'selected' : ''}>${type}</option>`
        ).join('');

        let typeClass = '';
        if (row.type === '입금') typeClass = 'deposit';
        else if (row.type === '출금') typeClass = 'withdrawal';
        else if (row.type === '출금취소') typeClass = 'cancel';
        else typeClass = 'other';

        tr.innerHTML = `
            <td>${formatDateCompact(row.timeline)}</td>
            <td>
                <select class="form-select form-select-sm category-select" data-id="${row.id}" onchange="updateCategory(this)">
                    <option value="" disabled ${!row.category ? 'selected' : ''}>선택</option>
                    ${categoryOptions}
                </select>
            </td>
            <td>${row.amount.toLocaleString('ko-KR')}</td>
            <td>${row.card}</td>
            <td>  
                <select class="form-select form-select-sm type-select ${typeClass}" data-id="${row.id}" onchange="updateType(this)">
                    <option value="" disabled>선택</option>
                    ${typeOptions}
                </select>
            </td>
            <td>${row.balance.toLocaleString('ko-KR')}</td>
            <td class="store-cell">${row.store}</td>
            <td>
                <input type="text" class="form-control form-control-sm memo-input" value="${row.memo || ''}" 
                    data-id="${row.id}" onblur="updateMemo(this)" />
            </td>
        `;

        // 새로운 행을 테이블의 가장 위쪽에 추가
        tbody.append(tr);
    }


    async function updateCategory(selectEl) {
      const newCategory = selectEl.value;
      const id = selectEl.getAttribute('data-id');

      const { error } = await supa
        .from('card_logs')
        .update({ category: newCategory })
        .eq('id', id);

      if (error) {
        alert('카테고리 업데이트 실패');
        console.error(error);
      } else {
        console.log(`✅ 카테고리 업데이트 완료: ${newCategory}`);
      }
    }

    async function updateType(selectEl) {
      const newType = selectEl.value;
      const id = selectEl.getAttribute('data-id');

      const { error } = await supa
        .from('card_logs')
        .update({ type: newType })
        .eq('id', id);

      if (error) {
        alert('종류 업데이트 실패');
        console.error(error);
      } else {
        console.log(`✅ 종류 업데이트 완료: ${newType}`);
      }
    }

    async function updateMemo(inputEl) {
      const newMemo = inputEl.value;
      const id = inputEl.getAttribute('data-id');

      const { error } = await supa
        .from('card_logs')
        .update({ memo: newMemo })
        .eq('id', id);

      if (error) {
        alert('메모 업데이트 실패');
        console.error(error);
      } else {
        console.log(`✅ 메모 업데이트 완료: ${newMemo}`);
      }
    }

    function populateTableFilter() {
      categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = cat;
        tableCategoryFilter.appendChild(option);
      });
    }

    // ✅ 최초 전체 로딩
    setDefaultDateRange();
    createCategoryButtons();
    populateTableFilter();
    loadTableData();

    // ✅ 실시간 삽입만 감지
    supa
      .channel('realtime:card_logs')
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'card_logs' },
        payload => {
          console.log('🆕 새 데이터 감지됨:', payload.new);
          appendRow(payload.new); 
        }
      )
      .subscribe();
  </script>
  <script src="/common/sidebar.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>

</body>
</html>
