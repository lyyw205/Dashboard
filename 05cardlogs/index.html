<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>카드 결제 내역</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="../common/sidebar.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
</head>
<body>
  <div class="cardlogs-main main-content">
    <div class="reservation container-fluid px-4 mt-5">
            <!-- NEW! 필터 및 차트 영역 -->
      <div class="filter-wrapper mt-5 mb-4">
        <h2 class="mb-3">📊 필터링 데이터 추출</h2>
        <div class="filter-section mb-3">
          <div class="row g-3 align-items-end">
            <!-- 날짜 범위 선택 -->
            <div class="col-md-2">
              <label for="startDate" class="form-label"><b>시작일</b></label>
              <input type="date" id="startDate" class="form-control">
            </div>
            <div class="col-md-2">
              <label for="endDate" class="form-label"><b>종료일</b></label>
              <input type="date" id="endDate" class="form-control">
            </div>
            <!-- 종류 선택 버튼 (입금/출금) -->
            <div class="col-md-2 w-auto">
              <label class="form-label d-block"><b>입/출금</b></label>
              <div id="type-buttons-container" class="d-flex flex-wrap gap-2">
                  <button class="btn type-btn active" data-type="출금">출금</button>
                  <button class="btn type-btn" data-type="입금">입금</button>
              </div>
            </div>
            <!-- 메모 인풋 -->
            <div class="memo-filter-wrapper col-md-4">
              <label for="memo-search-input" class="form-label"><strong>📝 메모 내용을 포함하는 항목 검색</strong></label>
              <input type="text" id="memo-search-input" class="form-control" placeholder="검색할 메모 내용을 입력하세요...">
            </div>
          </div>
          <!-- 카테고리 선택 버튼 -->
          <div class="mt-3">
            <label class="form-label d-block"><b>카테고리 (중복 선택 가능)</b></label>
            <div id="category-buttons-container" class="d-flex flex-wrap gap-2">
              <!-- JS로 버튼 동적 생성 -->
            </div>
          </div>
                    <!-- 조회 버튼 -->
          <div class="col-md-3 mt-3">
            <button id="filter-btn" class="btn btn-search w-100">조회하기</button>
          </div>
        </div>
        <div id="summary-container" class="summary-container mt-4 p-3 border rounded bg-light" style="display: none;">
          <h4>🔍 조회 결과 요약</h4>
          <div class="row">
            <div class="col-6">
              <p class="summary-label">총 입금액</p>
              <p id="total-deposit" class="summary-value deposit-color">0 원</p>
            </div>
            <div class="col-6">
              <p class="summary-label">총 출금액</p>
              <p id="total-withdrawal" class="summary-value withdrawal-color">0 원</p>
            </div>
          </div>
        </div>
        
        <!-- 차트가 그려질 영역 -->
        <div id="chart-container">
          <canvas id="category-chart"></canvas>
        </div>
      </div>
      <div class="table-wrapper d-flex flex-column mt-5 mb-3">
        <h2 class="mb-3 mb-md-3">💳카드 결제 내역</h2>
        <div class="p-3 mb-3 border rounded bg-light">
          <div class="row g-3">
            <!-- 날짜 필터 -->
            <div class="col-md-2">
              <label for="table-start-date" class="form-label"><strong> 시작일</strong></label>
              <input type="date" id="table-start-date" class="form-control">
            </div>
            <div class="col-md-2">
              <label for="table-end-date" class="form-label"><strong> 종료일</strong></label>
              <input type="date" id="table-end-date" class="form-control">
            </div>
            <!-- 카테고리 필터 -->
            <div class="mb-3 col-md-2">
              <label for="table-category-filter" class="form-label"><strong> 카테고리</strong></label>
              <select id="table-category-filter" class="form-select">
                <option value="all">-- 전체 보기 --</option>
                <!-- 카테고리는 JavaScript로 채워집니다 -->
              </select>
            </div>
                <!-- 종류 필터 -->
            <div class="col-md-2">
              <label for="table-type-filter" class="form-label"><strong> 종류</strong></label>
              <select id="table-type-filter" class="form-select">
                <option value="all">-- 전체 --</option>
                <option value="출금">출금</option>
                <option value="입금">입금</option>
              </select>
            </div>
            <div class="col-md-2">
              <label for="table-store-search" class="form-label"><strong> 결제처 검색</strong></label>
              <input type="text" id="table-store-search" class="form-control" placeholder="결제처명 입력">
            </div>
            <div class="col-md-2">
              <label for="table-memo-search" class="form-label"><strong> 메모 검색</strong></label>
              <input type="text" id="table-memo-search" class="form-control" placeholder="메모 내용 입력">
            </div>
          </div>
        </div>
        
        <div class="table-responsive">
          <table id="log-table" class="log-table table table-borderless table-hover align-middle text-center table-striped-custom">
            <thead class="table-dark">
              <tr>
                <th>시간</th>
                <th>카테고리</th>
                <th>금액</th>
                <th>카드</th>
                <th>종류</th>
                <th>잔액</th>
                <th>결제처</th>
                <th>메모</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
  <script>
    // ✅ 변수명 이름 충돌 방지
    const supa = window.supabase.createClient(
      'https://wqxmvqqkbxiykiotbusd.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndxeG12cXFrYnhpeWtpb3RidXNkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0NDcyOTYsImV4cCI6MjA2NDAyMzI5Nn0.RmB92YtjLPMx4tkQibuRVT_T4DL3_O8Pny3ZA9DU0tk'
    );
    Chart.register(ChartDataLabels);

    const categories = ['광고', '장소 대관', '안주/주류', '비품', '업무추진비', '공과금', '파티비', '현장판매', '대관', '기타'];

    //=======================================================
    // 차트 및 필터링 관련 로직
    //=======================================================
    const typeButtonsContainer = document.getElementById('type-buttons-container');
    const categoryButtonsContainer = document.getElementById('category-buttons-container');
    const filterBtn = document.getElementById('filter-btn');
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    let categoryChart = null; 
    const memoSearchInput = document.getElementById('memo-search-input');
    const tableStartDate = document.getElementById('table-start-date');
    const tableEndDate = document.getElementById('table-end-date');
    const tableTypeFilter = document.getElementById('table-type-filter');
    const tableCategoryFilter = document.getElementById('table-category-filter');
    const tableMemoSearch = document.getElementById('table-memo-search');
    const tableStoreSearch = document.getElementById('table-store-search');

    function formatDateForInput(input) {
      // 1. 입력값이 없는 경우, 에러 방지를 위해 빈 문자열 반환
      if (!input) return '';

      // 2. 입력값이 Date 객체인 경우 (setDefaultDateRange에서 호출될 때)
      if (input instanceof Date) {
        // toISOString()을 사용하면 'YYYY-MM-DDTHH:...' 형식이 되므로,
        // 앞 10자리를 잘라 'YYYY-MM-DD'를 반환합니다. 이 방법이 가장 안전합니다.
        return input.toISOString().slice(0, 10);
      }

      // 3. 입력값이 문자열인 경우 (applyTableFilters에서 호출될 때)
      if (typeof input === 'string' && input.length >= 10) {
        // 문자열의 앞 10자리를 잘라 'YYYY-MM-DD'를 반환합니다.
        return input.substring(0, 10);
      }
      
      // 4. 그 외의 모든 예외적인 경우
      return '';
    }

    // [신규] 기본 날짜 범위(오늘 ~ 2주 전)를 설정하는 함수
    function setDefaultDateRange() {
      const today = new Date();
      const twoWeeksAgo = new Date();
      twoWeeksAgo.setDate(today.getDate() - 14);

      endDateInput.value = formatDateForInput(today);
      startDateInput.value = formatDateForInput(twoWeeksAgo);
    }

    function createCategoryButtons() {
      categories.forEach(cat => {
        const button = document.createElement('button');
        button.className = 'btn btn-category category-btn'; // Use secondary for non-active
        button.textContent = cat;
        button.dataset.category = cat;
        categoryButtonsContainer.appendChild(button);
      });
    }
    
    typeButtonsContainer.addEventListener('click', (e) => {
      if (e.target.classList.contains('type-btn')) {
        // 클릭된 버튼의 active 클래스를 단순히 토글(toggle)만 합니다.
        e.target.classList.toggle('active');
      }
    });

    categoryButtonsContainer.addEventListener('click', (e) => {
      // 버튼이 'category-btn' 클래스를 가지고 있는지 확인
      if (e.target.classList.contains('category-btn')) {
        // 'active' 클래스를 붙였다 떼는(토글) 역할만 수행
        e.target.classList.toggle('active');
      }
    });

    filterBtn.addEventListener('click', async () => {
        const startDateValue = startDateInput.value; // 예: "2025-07-19"
        const endDateValue = endDateInput.value;   // 예: "2025-07-20"

        if (!startDateValue || !endDateValue) {
            alert('시작일과 종료일을 모두 선택해주세요.');
            return;
        }

        // [✅ 이렇게 수정됩니다]
        // new Date()와 .toISOString()을 모두 제거합니다.
        // 사용자가 선택한 날짜 문자열에 시간 정보만 붙여서 DB로 보낼 문자열을 만듭니다.
        // 이렇게 하면 시간대 변환이 전혀 일어나지 않습니다.
        const startDateForDB = `${startDateValue} 00:00:00`;
        const endDateForDB = `${endDateValue} 23:59:59`;

        console.log("📊 차트 필터링 조회 시작 (시간대 변환 없음)", {
            "사용자 선택 시작일": startDateValue,
            "사용자 선택 종료일": endDateValue,
            "DB 조회 시작일시": startDateForDB,
            "DB 조회 종료일시": endDateForDB
        });

        const selectedChartTypes = Array.from(typeButtonsContainer.querySelectorAll('.type-btn.active')).map(btn => btn.dataset.type);
        const chartTypesToQuery = [...selectedChartTypes];
        if (selectedChartTypes.includes('출금') && !chartTypesToQuery.includes('출금취소')) {
            chartTypesToQuery.push('출금취소');
        }

        if (chartTypesToQuery.length === 0) {
            alert('하나 이상의 종류(입금/출금)를 선택해주세요.');
            return;
        }

        const selectedChartCategories = Array.from(categoryButtonsContainer.querySelectorAll('.category-btn.active')).map(btn => btn.dataset.category);
        if (selectedChartCategories.length === 0) {
            alert('하나 이상의 카테고리를 선택해주세요.');
            return;
        }

        const chartMemoText = memoSearchInput.value.trim();
        
        // 생성된 'YYYY-MM-DD HH:mm:ss' 형식의 문자열을 그대로 전달합니다.
        await fetchDataAndDisplayResults(startDateForDB, endDateForDB, selectedChartCategories, chartTypesToQuery, chartMemoText);
    });

    function applyTableFilters() {
        const startDate = tableStartDate.value;
        const endDate = tableEndDate.value;
        const selectedType = tableTypeFilter.value;
        const selectedCategory = tableCategoryFilter.value;
        const searchText = tableMemoSearch.value.toLowerCase().trim();
        const storeSearchText = tableStoreSearch.value.toLowerCase().trim();

        const tableRows = document.querySelectorAll('#log-table tbody tr');

        tableRows.forEach(row => {
            // 1. row에 저장된 UTC 시간(ISO 문자열)을 가져온다.
            const rowTimelineUTC = row.dataset.timeline;
            if (!rowTimelineUTC) { // timeline 데이터가 없는 row는 무시
                row.style.display = 'none';
                return;
            }

            // 2. UTC 문자열로 KST 기준의 Date 객체를 생성한다.
            const rowKSTDateStr = formatDateForInput(rowTimelineUTC);
            
            const rowType = row.querySelector('.type-select')?.value;
            const rowCategory = row.querySelector('.category-select')?.value;
            const memoText = (row.querySelector('.memo-input')?.value || '').toLowerCase();
            const storeText = (row.querySelector('.store-cell')?.textContent || '').toLowerCase();

            // 필터 조건 검사
            const dateMatch = (!startDate || rowKSTDateStr >= startDate) && (!endDate || rowKSTDateStr <= endDate);
            
            let typeMatch = true;
            if (selectedType === '출금') {
                typeMatch = (rowType === '출금' || rowType === '출금취소');
            } else if (selectedType !== 'all') {
                typeMatch = (rowType === selectedType);
            }

            const categoryMatch = selectedCategory === 'all' || rowCategory === selectedCategory;
            const memoMatch = memoText.includes(searchText);
            const storeMatch = storeText.includes(storeSearchText);

            // 최종적으로 보여줄지 말지 결정
            if (dateMatch && typeMatch && categoryMatch && memoMatch && storeMatch) {
                row.style.display = ''; // 테이블의 기본 tr display 속성으로 복원
            } else {
                row.style.display = 'none';
            }
        });
    }
    
    async function fetchDataAndDisplayResults(startDate, endDate, categories, typesToQuery, memoText) {
        // 1. DB에서 데이터 조회
        let query = supa.from('card_logs').select('category, amount, type')
            .in('type', typesToQuery)
            .gte('timeline', startDate)
            .lte('timeline', endDate)
            .in('category', categories);
        if (memoText) query = query.ilike('memo', `%${memoText}%`);

        const { data: rawData, error } = await query;
        if (error) { /* ... */ return; }

        // 2. 총액 계산 및 화면 표시
        let totalDeposit = 0;
        let totalWithdrawal = 0;
        rawData.forEach(item => {
            if (item.type === '입금') totalDeposit += item.amount;
            else if (item.type === '출금') totalWithdrawal += item.amount;
            else if (item.type === '출금취소') totalWithdrawal -= item.amount;
        });
        document.getElementById('total-deposit').textContent = `${formatNumber(totalDeposit)} 원`;
        document.getElementById('total-withdrawal').textContent = `${formatNumber(totalWithdrawal)} 원`;
        document.getElementById('summary-container').style.display = 'block';

        // 3. 카테고리별 데이터 집계
        const depositCategoryTotals = {};
        const withdrawalCategoryTotals = {};
        categories.forEach(cat => {
            depositCategoryTotals[cat] = 0;
            withdrawalCategoryTotals[cat] = 0;
        });
        rawData.forEach(item => {
            if (item.type === '입금') {
                if (depositCategoryTotals.hasOwnProperty(item.category)) depositCategoryTotals[item.category] += item.amount;
            } else if (item.type === '출금' || item.type === '출금취소') {
                if (withdrawalCategoryTotals.hasOwnProperty(item.category)) {
                    if(item.type === '출금') withdrawalCategoryTotals[item.category] += item.amount;
                    else withdrawalCategoryTotals[item.category] -= item.amount;
                }
            }
        });

        // 4. ★★★ 실제 차트에 표시할 데이터만 필터링 ★★★
        const dynamicLabels = [];
        const dynamicDepositValues = [];
        const dynamicWithdrawalValues = [];
        categories.forEach(label => {
            const depositValue = depositCategoryTotals[label] || 0;
            const withdrawalValue = withdrawalCategoryTotals[label] || 0;
            if (depositValue > 0 || withdrawalValue > 0) {
                dynamicLabels.push(label);
                dynamicDepositValues.push(depositValue);
                dynamicWithdrawalValues.push(withdrawalValue);
            }
        });

        // 5. 모든 가공이 끝난 최종 데이터를 다음 함수에 전달
        renderDualCategoryChart(dynamicLabels, dynamicDepositValues, dynamicWithdrawalValues, totalDeposit, totalWithdrawal);
    }
        
    function renderDualCategoryChart(chartLabels, depositValues, withdrawalValues, totalDeposit, totalWithdrawal) {
        const chartContainer = document.getElementById('chart-container');
        const ctx = document.getElementById('category-chart').getContext('2d');
        
        if (categoryChart) {
            categoryChart.destroy();
        }

        // ★★★ (핵심) 가운데 정렬을 위한 패딩 로직 ★★★
        // 이 함수는 이제 데이터 가공 없이 전달받은 값을 그대로 사용합니다.
        const MIN_DISPLAY_CATEGORIES = 7;
        const numActiveCategories = chartLabels.length;

        let finalLabels = chartLabels;
        let finalDepositValues = depositValues;
        let finalWithdrawalValues = withdrawalValues;

        if (numActiveCategories > 0 && numActiveCategories < MIN_DISPLAY_CATEGORIES) {
            const paddingCount = Math.floor((MIN_DISPLAY_CATEGORIES - numActiveCategories) / 2);
            const labelPadding = Array(paddingCount).fill('');
            const dataPadding = Array(paddingCount).fill(null);
            finalLabels = [...labelPadding, ...chartLabels, ...labelPadding];
            finalDepositValues = [...dataPadding, ...depositValues, ...dataPadding];
            finalWithdrawalValues = [...dataPadding, ...withdrawalValues, ...dataPadding];
        }
        // ★★★ 패딩 로직 끝 ★★★


        // --- 3. 차트 렌더링 ---
        const chartTitle = '선택된 기간 및 카테고리별 입/출금 현황';

        categoryChart = new Chart(ctx, {
            type: 'bar',
            data: {
                // ★★★ 패딩이 적용된 최종 데이터를 사용합니다 ★★★
                labels: finalLabels,
                datasets: [
                    {
                        label: '총 입금액 (원)',
                        data: finalDepositValues,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)'
                        // maxBarThickness 등은 이제 불필요하므로 제거해도 좋습니다.
                    },
                    {
                        label: '총 출금액 (원)',
                        data: finalWithdrawalValues,
                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                        borderColor: 'rgba(255, 99, 132, 1)'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                // bar 관련 너비 옵션
                categoryPercentage: 0.8, // 카테고리 열 내에서 막대 그룹이 차지하는 너비 비율
                barPercentage: 0.7,      // 막대 그룹 내에서 각 막대가 차지하는 너비 비율
                plugins: {
                    // 데이터 라벨 플러그인 설정은 그대로 유지
                    datalabels: {
                        display: context => context.dataset.data[context.dataIndex] > 0,
                        formatter: (value, context) => {
                            let total = context.datasetIndex === 0 ? totalDeposit : totalWithdrawal;
                            const percentage = total > 0 ? (value / total) * 100 : 0;
                            const formattedValue = new Intl.NumberFormat('ko-KR').format(value);
                            return `${formattedValue}\n(${percentage.toFixed(1)}%)`;
                        },
                        anchor: 'end',
                        align: 'center',
                        offset: 7,
                        font: {
                            family: "'Pretendard Variable', sans-serif", // 원하는 폰트 패밀리 지정
                            weight: '400',
                            size: 11,
                            lineHeight: 1.2 // 줄 간격 조절
                        },
                        color: '#333'
                    },
                    title: { display: true, text: chartTitle, font: { size: 16 } },
                    legend: { position: 'top' },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          let label = context.dataset.label || '';
                          if (label) { label += ': '; }
                          if (context.parsed.y !== null) {
                              label += new Intl.NumberFormat('ko-KR').format(context.parsed.y) + ' 원';
                          }
                          return label;
                        }
                      }
                    }
                },
                scales: {
                    x: {
                        stacked: false,
                    },
                    y: {
                        stacked: false,
                        beginAtZero: true,
                        ticks: {
                            callback: value => new Intl.NumberFormat('ko-KR').format(value)
                        },
                        grace: '20%'
                    }
                }
            }
        });
        chartContainer.style.display = 'block';
    }

    // [수정] 모든 필터 이벤트가 통합 함수를 호출하도록 연결
    tableStartDate.addEventListener('change', applyTableFilters);
    tableEndDate.addEventListener('change', applyTableFilters);
    tableTypeFilter.addEventListener('change', applyTableFilters); // 새로 추가된 드롭다운의 이벤트
    tableCategoryFilter.addEventListener('change', applyTableFilters);
    tableMemoSearch.addEventListener('input', applyTableFilters);
    tableStoreSearch.addEventListener('input', applyTableFilters);

    //=======================================================
    // 기존 테이블 관련 로직
    //=======================================================
    async function loadInitialLogs() {
      const { data, error } = await supa
        .from('card_logs')
        .select('*')
        .order('timeline', { ascending: true });

      if (error) {
        console.error('초기 로드 오류:', error);
        return;
      }

      const tbody = document.querySelector('#log-table tbody');
      tbody.innerHTML = '';

      data.forEach(row => { // reverse()를 제거하고 forEach로 변경
        appendRow(row);     // appendRow는 이제 prepend로 동작하므로 순서가 맞음
      });
      
      // 모든 데이터를 DOM에 추가한 후, 마지막에 필터를 한번 전체 적용
      applyTableFilters(); 
    }

    function formatNumber(num) {
      return typeof num === 'number' ? num.toLocaleString('ko-KR') : '';
    } 

    function formatDateCompact(dateString) {
      if (!dateString || dateString.length < 16) return '';

      // "2025-07-19T18:54:00+00:00" 형태의 문자열을 가정
      const month = dateString.substring(5, 7);
      const day = dateString.substring(8, 10);
      const hour = dateString.substring(11, 13);
      const minute = dateString.substring(14, 16);

      return `${month}/${day} ${hour}:${minute}`;
    }


    function appendRow(row) {
        const tbody = document.querySelector('#log-table tbody');
        const tr = document.createElement('tr');
        // KST/UTC 혼동을 막기 위해 기준이 되는 UTC 시간을 data 속성에 저장
        tr.dataset.timeline = row.timeline;

        const categoryOptions = categories.map(cat =>
            `<option value="${cat}" ${row.category === cat ? 'selected' : ''}>${cat}</option>`
        ).join('');
        const typeOptions = ['출금', '입금', '출금취소', '기타'].map(type =>
            `<option value="${type}" ${row.type === type ? 'selected' : ''}>${type}</option>`
        ).join('');

        let typeClass = '';
        if (row.type === '입금') typeClass = 'deposit';
        else if (row.type === '출금') typeClass = 'withdrawal';
        else if (row.type === '출금취소') typeClass = 'cancel';
        else typeClass = 'other';

        tr.innerHTML = `
            <td>${formatDateCompact(row.timeline)}</td>
            <td>
                <select class="form-select form-select-sm category-select" data-id="${row.id}" onchange="updateCategory(this)">
                    <option value="" disabled ${!row.category ? 'selected' : ''}>선택</option>
                    ${categoryOptions}
                </select>
            </td>
            <td>${row.amount.toLocaleString('ko-KR')}</td>
            <td>${row.card}</td>
            <td>  
                <select class="form-select form-select-sm type-select ${typeClass}" data-id="${row.id}" onchange="updateType(this)">
                    <option value="" disabled>선택</option>
                    ${typeOptions}
                </select>
            </td>
            <td>${row.balance.toLocaleString('ko-KR')}</td>
            <td class="store-cell">${row.store}</td>
            <td>
                <input type="text" class="form-control form-control-sm memo-input" value="${row.memo || ''}" 
                    data-id="${row.id}" onblur="updateMemo(this)" />
            </td>
        `;

        // 새로운 행을 테이블의 가장 위쪽에 추가
        tbody.prepend(tr);
    }


    async function updateCategory(selectEl) {
      const newCategory = selectEl.value;
      const id = selectEl.getAttribute('data-id');

      const { error } = await supa
        .from('card_logs')
        .update({ category: newCategory })
        .eq('id', id);

      if (error) {
        alert('카테고리 업데이트 실패');
        console.error(error);
      } else {
        console.log(`✅ 카테고리 업데이트 완료: ${newCategory}`);
      }
    }

    async function updateType(selectEl) {
      const newType = selectEl.value;
      const id = selectEl.getAttribute('data-id');

      const { error } = await supa
        .from('card_logs')
        .update({ type: newType })
        .eq('id', id);

      if (error) {
        alert('종류 업데이트 실패');
        console.error(error);
      } else {
        console.log(`✅ 종류 업데이트 완료: ${newType}`);
      }
    }

    async function updateMemo(inputEl) {
      const newMemo = inputEl.value;
      const id = inputEl.getAttribute('data-id');

      const { error } = await supa
        .from('card_logs')
        .update({ memo: newMemo })
        .eq('id', id);

      if (error) {
        alert('메모 업데이트 실패');
        console.error(error);
      } else {
        console.log(`✅ 메모 업데이트 완료: ${newMemo}`);
      }
    }

    function populateTableFilter() {
      categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = cat;
        tableCategoryFilter.appendChild(option);
      });
    }

    // ✅ 최초 전체 로딩
    setDefaultDateRange();
    createCategoryButtons();
    populateTableFilter();
    loadInitialLogs();

    // ✅ 실시간 삽입만 감지
    supa
      .channel('realtime:card_logs')
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'card_logs' },
        payload => {
          console.log('🆕 새 데이터 감지됨:', payload.new);
          appendRow(payload.new); 
        }
      )
      .subscribe();
  </script>
  <script src="/common/sidebar.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>

</body>
</html>
